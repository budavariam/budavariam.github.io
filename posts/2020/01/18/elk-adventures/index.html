<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ELK adventures | Mátyás Budavári</title><meta name=keywords content="programming,logs,devops,docker,elk-stack"><meta name=description content="I have an application that logs a lot, and during development I got tired of looking through the command line for the error logs, that were hidden by other logs (that were also necessary). So I looked around what is the preferred way of handling logs nowadays."><meta name=author content="Mátyás Budavári"><meta name=theme-color content="#317EFB"><link rel=canonical href=https://budavariam.github.io/posts/2020/01/18/elk-adventures/><meta name=google-site-verification content="ocrG4G5ZSn2awC0mgHAsgk2qlhd3IAXCACgWNrqJcwY"><link href=/assets/css/stylesheet.min.f49dca1388bbfc51e75e0b33e973a7fab4aa840ffa791250558590d60aa9cb27.css integrity="sha256-9J3KE4i7/FHnXgsz6XOn+rSqhA/6eRJQVYWQ1gqpyyc=" rel="preload stylesheet" as=style><link rel=icon href=https://budavariam.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://budavariam.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://budavariam.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://budavariam.github.io/favicon/apple-icon-180x180.png><link rel=mask-icon href=https://budavariam.github.io/favicon/apple-icon-180x180.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-115499513-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="ELK adventures"><meta property="og:description" content="I have an application that logs a lot, and during development I got tired of looking through the command line for the error logs, that were hidden by other logs (that were also necessary). So I looked around what is the preferred way of handling logs nowadays."><meta property="og:type" content="article"><meta property="og:url" content="https://budavariam.github.io/posts/2020/01/18/elk-adventures/"><meta property="article:published_time" content="2020-01-18T00:00:00+00:00"><meta property="article:modified_time" content="2020-01-18T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary"><meta name=twitter:title content="ELK adventures"><meta name=twitter:description content="I have an application that logs a lot, and during development I got tired of looking through the command line for the error logs, that were hidden by other logs (that were also necessary). So I looked around what is the preferred way of handling logs nowadays."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://budavariam.github.io/posts/"},{"@type":"ListItem","position":2,"name":"ELK adventures","item":"https://budavariam.github.io/posts/2020/01/18/elk-adventures/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ELK adventures","name":"ELK adventures","description":"I have an application that logs a lot, and during development I got tired of looking through the command line for the error logs, that were hidden by other logs (that were also …","keywords":["programming","logs","devops","docker","elk-stack"],"articleBody":"I have an application that logs a lot, and during development I got tired of looking through the command line for the error logs, that were hidden by other logs (that were also necessary). So I looked around what is the preferred way of handling logs nowadays.\nSome years ago I’ve worked on a project, where we used the ELK stack to provide configurable dashboards and realtime logs for monitoring. We used it, but I was not working with it directly. It seemed like a good idea to revisit how it actually works.\nI already knew that I only want to play around with it so I did not need to run a production ready server for it.\nFor my usecase a local virtualized install would do. I searched for existing configured stacks, and I’ve found exactly what I was looking for. Huge thanks for deviantony’s docker-elk repository. I forked it and started to explore.\nMy github repo is available here.\nWhat is ELK ELK is a stack that consists of 3 opensource tools Elasticsearch, Logstash and Kibana and lets you store logs and create visualizations based on those logs in realtime.\n Logstash collects the logs Elasticsearch stores them Kibana lets you visualize and explore them  Simple as that.\nFilebeat What the starting stack was missing was a way to send logs to logstash. I read about different ways and decided to add a filebeat extension to read logs from the file system.\n Beats is the platform for single-purpose data shippers. They send data from hundreds or thousands of machines and systems to Logstash or Elasticsearch.\n source\nElasticsearch provides docker image for these beats, so the configuration was pretty straightforward.\nARG ELK_VERSIONFROMdocker.elastic.co/beats/filebeat:${ELK_VERSION}I needed to provide a config, and a volume to /var/log/apps.\nIn my configuration I experimented with multiline configuration, to avoid sending multiple entries for a single log message.\nI check if the line matches with the ^(DEBUG|INFO|WARNING|ERROR|FATAL) regexp, if it does, then starts a new line, otherwise the line gets appended to the previous line.\nmultiline.pattern: '^(DEBUG|INFO|WARNING|ERROR|FATAL)' multiline.negate: true multiline.match: after Logstash I’ve played around with logstash configurations for a while, until I found a solution that I was happy with. I’ve found GROK debugger a useful tool, and it helped me to browse the basic types.\nWhile I was playing around it made me realize how important it is to provide consistent and easily parsable logs to make monitoring and error research easier to track bugs.\nSplit log message My golang code logs with a specific logger. Logstash gave me a hard time and docs/github issue browsing until I found that golang supports nanosecond precision while elasticsearch “only” uses microseconds precision, so I needed to trim the last 3 digits from the timestamp.\ngrok { match = { \"source\" = \"%{GREEDYDATA}/%{GREEDYDATA:app}.log\" \"message\" = \"%{LOGLEVEL:loglevel}:\\s+(?%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME})\\s+%{GREEDYDATA:logmsg}\" } } ## golang has nanosecond precision, elasticsearch has microseconds precision, trim last 3 numbers mutate { gsub = [\"timestamp\",\"\\d\\d\\d$\",\"\"] } Use log date as @timestamp The next challenge that I gave myself to use log date as the elasticsearch timestamp. In logstash it is straightforward, I need to use the date filter to convert my data to date, it needs the source with the timestamp format and the target field.\ndate { match = [ \"timestamp\", \"YYYY/MM/dd HH:mm:ss.SSS\" ] target = \"@timestamp\" } Putting it all together I fired it all up with docker-compose -f docker-compose.yml -f extensions/filebeat-compose/filebeat-compose.yml up.\nI needed to add an index pattern to match logstash, and wait for micarle. When when the data finally started to flow and show up in kibana it was an amazing feeling, that was worth the few days of fiddling around.\nI managed to separate the data from the logs that I needed, and now I am able to save queries and dashboards based on specific cases.\nFinal thoughts I felt lucky that one version number is necessary, and it just works. I can imagine that it can be painful to manage configuration errors.\nI usually work in both frontend and backend side of the code, recently I got into managing CI/CD pipelines and deploying to different environments, but now I felt like I got a bit more taste of the devops world.\n","wordCount":"701","inLanguage":"en","datePublished":"2020-01-18T00:00:00Z","dateModified":"2020-01-18T00:00:00Z","author":{"@type":"Person","name":"Mátyás Budavári"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://budavariam.github.io/posts/2020/01/18/elk-adventures/"},"publisher":{"@type":"Organization","name":"Mátyás Budavári","logo":{"@type":"ImageObject","url":"https://budavariam.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://budavariam.github.io/ accesskey=h title="Mátyás Budavári (Alt + H)" class=site-avatar><img src=/avatar.png alt=logo aria-label=logo height=70 width=70></a><div class=site-info><h1 class=site-name><a href=https://budavariam.github.io/ accesskey=h title="Mátyás Budavári (Alt + H)">Mátyás Budavári</a></h1><p class=site-description>Developer from Szeged</p></div></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://budavariam.github.io/about/ title=About><span>About</span></a></li><li><a href=https://budavariam.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://budavariam.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://budavariam.github.io/archives/ title=Archive><span>Archive</span></a></li><li><span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>ELK adventures</h1><div class=post-meta>January 18, 2020&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Mátyás Budavári</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#what-is-elk aria-label="What is ELK">What is ELK</a></li><li><a href=#filebeat aria-label=Filebeat>Filebeat</a></li><li><a href=#logstash aria-label=Logstash>Logstash</a><ul><li><a href=#split-log-message aria-label="Split log message">Split log message</a></li><li><a href=#use-log-date-as-timestamp aria-label="Use log date as @timestamp">Use log date as @timestamp</a></li></ul></li><li><a href=#putting-it-all-together aria-label="Putting it all together">Putting it all together</a></li><li><a href=#final-thoughts aria-label="Final thoughts">Final thoughts</a></li></ul></div></details></div><div class=post-content><p>I have an application that logs a lot, and during development I got tired of looking through the command line for the error logs, that were hidden by other logs (that were also necessary). So I looked around what is the preferred way of handling logs nowadays.</p><p>Some years ago I&rsquo;ve worked on a project, where we used the ELK stack to provide configurable dashboards and realtime logs for monitoring. We used it, but I was not working with it directly. It seemed like a good idea to revisit how it actually works.</p><p>I already knew that I only want to play around with it so I did not need to run a production ready server for it.</p><p>For my usecase a local virtualized install would do. I searched for existing configured stacks, and I&rsquo;ve found exactly what I was looking for. Huge thanks for <a href=https://github.com/deviantony/docker-elk>deviantony&rsquo;s docker-elk</a> repository. I forked it and started to explore.</p><p>My github repo is available <a href=https://github.com/budavariam/docker-elk>here</a>.</p><h2 id=what-is-elk>What is ELK<a hidden class=anchor aria-hidden=true href=#what-is-elk>#</a></h2><p>ELK is a stack that consists of 3 opensource tools Elasticsearch, Logstash and Kibana and lets you store logs and create visualizations based on those logs in realtime.</p><ul><li>Logstash collects the logs</li><li>Elasticsearch stores them</li><li>Kibana lets you visualize and explore them</li></ul><p>Simple as that.</p><h2 id=filebeat>Filebeat<a hidden class=anchor aria-hidden=true href=#filebeat>#</a></h2><p>What the starting stack was missing was a way to send logs to logstash. I read about different ways and decided to add a filebeat extension to read logs from the file system.</p><blockquote><p>Beats is the platform for single-purpose data shippers. They send data from hundreds or thousands of machines and systems to Logstash or Elasticsearch.</p></blockquote><p><a href=https://www.elastic.co/products/beats>source</a></p><p>Elasticsearch provides docker image for these beats, so the configuration was pretty straightforward.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#66d9ef>ARG</span> ELK_VERSION<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> docker.elastic.co/beats/filebeat:${ELK_VERSION}</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>I needed to provide a config, and a volume to <code>/var/log/apps</code>.</p><p>In my configuration I experimented with <a href=https://www.elastic.co/guide/en/beats/filebeat/current/multiline-examples.html>multiline configuration</a>, to avoid sending multiple entries for a single log message.</p><p>I check if the line matches with the <code>^(DEBUG|INFO|WARNING|ERROR|FATAL)</code> regexp, if it does, then starts a new line, otherwise the line gets appended to the previous line.</p><pre><code class=language-conf data-lang=conf>multiline.pattern: '^(DEBUG|INFO|WARNING|ERROR|FATAL)'
multiline.negate: true
multiline.match: after
</code></pre><h2 id=logstash>Logstash<a hidden class=anchor aria-hidden=true href=#logstash>#</a></h2><p>I&rsquo;ve played around with logstash configurations for a while, until I found a solution that I was happy with. I&rsquo;ve found <a href=https://grokdebug.herokuapp.com/>GROK debugger</a> a useful tool, and it helped me to <a href=https://github.com/logstash-plugins/logstash-patterns-core/blob/master/patterns/grok-patterns>browse the basic types</a>.</p><p>While I was playing around it made me realize how important it is to provide consistent and easily parsable logs to make monitoring and error research easier to track bugs.</p><h3 id=split-log-message>Split log message<a hidden class=anchor aria-hidden=true href=#split-log-message>#</a></h3><p>My golang code logs with a <a href=https://github.com/palette-software/go-log-targets>specific logger</a>. Logstash gave me a hard time and docs/github issue browsing until I found that golang supports nanosecond precision while elasticsearch &ldquo;only&rdquo; uses microseconds precision, so I needed to trim the last 3 digits from the timestamp.</p><pre><code class=language-conf data-lang=conf>grok {
    match =&gt; {
        &quot;source&quot; =&gt; &quot;%{GREEDYDATA}/%{GREEDYDATA:app}.log&quot;
        &quot;message&quot; =&gt; &quot;%{LOGLEVEL:loglevel}:\s+(?&lt;timestamp&gt;%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME})\s+%{GREEDYDATA:logmsg}&quot;
    }
}
## golang has nanosecond precision, elasticsearch has microseconds precision, trim last 3 numbers
mutate {
    gsub =&gt; [&quot;timestamp&quot;,&quot;\d\d\d$&quot;,&quot;&quot;]
}
</code></pre><h3 id=use-log-date-as-timestamp>Use log date as @timestamp<a hidden class=anchor aria-hidden=true href=#use-log-date-as-timestamp>#</a></h3><p>The next challenge that I gave myself to use log date as the elasticsearch timestamp.
In logstash it is straightforward, I need to use the date filter to convert my data to date, it needs the source with the timestamp format and the target field.</p><pre><code class=language-conf data-lang=conf>date {
    match =&gt; [ &quot;timestamp&quot;, &quot;YYYY/MM/dd HH:mm:ss.SSS&quot; ]
    target =&gt; &quot;@timestamp&quot;
}
</code></pre><h2 id=putting-it-all-together>Putting it all together<a hidden class=anchor aria-hidden=true href=#putting-it-all-together>#</a></h2><p>I fired it all up with <code>docker-compose -f docker-compose.yml -f extensions/filebeat-compose/filebeat-compose.yml up</code>.</p><p>I needed to add an index pattern to match logstash, and wait for micarle.
When when the data finally started to flow and show up in kibana it was an amazing feeling, that was worth the few days of fiddling around.</p><p>I managed to separate the data from the logs that I needed, and now I am able to save queries and dashboards based on specific cases.</p><h2 id=final-thoughts>Final thoughts<a hidden class=anchor aria-hidden=true href=#final-thoughts>#</a></h2><p>I felt lucky that one version number is necessary, and it just works. I can imagine that it can be painful to manage configuration errors.</p><p>I usually work in both frontend and backend side of the code, recently I got into managing CI/CD pipelines and deploying to different environments, but now I felt like I got a bit more taste of the devops world.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://budavariam.github.io/tags/programming/>programming</a></li><li><a href=https://budavariam.github.io/tags/logs/>logs</a></li><li><a href=https://budavariam.github.io/tags/devops/>devops</a></li><li><a href=https://budavariam.github.io/tags/docker/>docker</a></li><li><a href=https://budavariam.github.io/tags/elk-stack/>elk-stack</a></li></ul><div class=share-buttons><div class=addthis_inline_share_toolbox></div><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-602c2f70bcebfd93"></script></div></div></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//budavariam.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href=https://budavariam.github.io/>Mátyás Budavári</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>