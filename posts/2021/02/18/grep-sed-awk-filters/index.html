<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Grep Sed AWK Filters | Mátyás Budavári</title><meta name=keywords content="programming,developer-toolbox,grep,sed,AWK,cheatsheet"><meta name=description content="I usually work with *nix systems, and I process text all the time.
This consists of CLI tool output, config file modifications and log files scanning.
These utilities make it easy to search and manipulate plaintext data.
I think they&rsquo;re an essential part of any developer&rsquo;s toolbox."><meta name=author content="Mátyás Budavári"><meta name=theme-color content="#317EFB"><link rel=canonical href=https://budavariam.github.io/posts/2021/02/18/grep-sed-awk-filters/><meta name=google-site-verification content="ocrG4G5ZSn2awC0mgHAsgk2qlhd3IAXCACgWNrqJcwY"><link href=/assets/css/stylesheet.min.5d8e42f9cb497547a4408e1c361839c57d0c6eff2e709ca4dba62f5b615c3463.css integrity="sha256-XY5C+ctJdUekQI4cNhg5xX0Mbv8ucJyk26YvW2FcNGM=" rel="preload stylesheet" as=style><link rel=icon href=https://budavariam.github.io/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://budavariam.github.io/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://budavariam.github.io/favicon/favicon-32x32.png><link rel=apple-touch-icon href=https://budavariam.github.io/favicon/apple-icon-180x180.png><link rel=mask-icon href=https://budavariam.github.io/favicon/apple-icon-180x180.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-115499513-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Grep Sed AWK Filters"><meta property="og:description" content="I usually work with *nix systems, and I process text all the time.
This consists of CLI tool output, config file modifications and log files scanning.
These utilities make it easy to search and manipulate plaintext data.
I think they&rsquo;re an essential part of any developer&rsquo;s toolbox."><meta property="og:type" content="article"><meta property="og:url" content="https://budavariam.github.io/posts/2021/02/18/grep-sed-awk-filters/"><meta property="og:image" content="https://budavariam.github.io/avatar.png"><meta property="article:published_time" content="2021-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-18T00:00:00+00:00"><meta property="og:site_name" content="Mátyás Budavári"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://budavariam.github.io/avatar.png"><meta name=twitter:title content="Grep Sed AWK Filters"><meta name=twitter:description content="I usually work with *nix systems, and I process text all the time.
This consists of CLI tool output, config file modifications and log files scanning.
These utilities make it easy to search and manipulate plaintext data.
I think they&rsquo;re an essential part of any developer&rsquo;s toolbox."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://budavariam.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Grep Sed AWK Filters","item":"https://budavariam.github.io/posts/2021/02/18/grep-sed-awk-filters/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Grep Sed AWK Filters","name":"Grep Sed AWK Filters","description":"I usually work with *nix systems, and I process text all the time. This consists of CLI tool output, config file modifications and log files scanning. These utilities make it easy …","keywords":["programming","developer-toolbox","grep","sed","AWK","cheatsheet"],"articleBody":"I usually work with *nix systems, and I process text all the time. This consists of CLI tool output, config file modifications and log files scanning. These utilities make it easy to search and manipulate plaintext data. I think they’re an essential part of any developer’s toolbox.\nThese commands can read either from the standard input, a single file or multiple files.\nGrep Grep’s name comes from the ed command g/re/p, which roughly means, globally look for a regular expression and print. Perfect for simple regex matches of single lines.\ngrep [flags] [pattern] [filenames]\nNotable grep flags  -E extended regexp -q exit code marks the result (success is 0) -v lines that do not match -n matched line and line number -l only the names of files that contain a match -c count of the matching lines (not the number of matches) -i case insensitive match -o print only matching part (interesting with regex) -e define multiple patterns --color use colors always/never/auto  Grep examples example=\"\\ For instance, on the planet Earth, man had always assumed that he was more intelligent than dolphins because he had achieved so much — the wheel, New York, wars and so on — whilst all the dolphins had ever done was muck about in the water having a good time. But conversely, the dolphins had always believed that they were far more intelligent than man — for precisely the same reasons.\" # Match exact text echo \"$example\" | grep 'man' # Match exactly 'the', 'than' or 'for' words # case insensitive (\\b is word boundary) echo \"$example\" | grep -iE '\\b(the|than|for)\\b' # Print only the matching part of the string # (can not print part of it, like groups) echo \"$example\" | grep -Eo 'dolphins \\w+' # Do not print lines that contain \"the\" echo \"$example\" | grep -Ev '\\bthe\\b' # Count the lines that contain \"good\" echo \"$example\" | grep -c 'good' # Filter lines that contain a # punctuation mark OR start with a lowercase letter echo \"$example\" | grep --color=never -E -e '[.,-]' -e '^[a-z]' Similar utilities  egrep - extended regex pattern, like grep -E fgrep - faster, but works only for fixed patterns zgrep/zegrep/zfgrep - for compressed files pgrep - search processes and print the PID of matching ones ack-grep has the functionality of grep, but optimized for developers silver seracher is similar to ack, but faster  Sed Sed is a powerful stream editor. For a more comprehensive guide check out this awesome post.\nI’ll show some commands that you can be productive with in no time.\nsed [flags] [pattern] [filenames]\nNotable sed flags  -E extended regexp -n show ony those lines, that we explicitly print -e chain multiple commands -i edit files in place  Basic commands  print: p delete: d substitute: s/regexp pattern/replace to this string/modifiers  fence characters after substitutiion that defines the fields can be any character, choose one that does not appear in your patterns. It has to be a single character. in replace string you can matching regular expression:  \u0026 to reference the whole pattern \\1-\\9 to reference the groups by number   modifiers can be:  g: global flag, match all occurrances in each line p: print result NUMBER: the NUMBERth match in the line      Addresses You can optionally specify addresses before the command in which the command acts upon:\n line number line range separated by comma, where the last line can be referenced with $ a regular expression to define which lines do you want to run the script to fenced by forward slashes  Addresses can be negated if you put a ! between the address and the command.\nSed Examples example=\"\\ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut ut enim quis nisl ultrices molestie eu in nibh. In sit amet odio et tellus sagittis semper sed at urna. Pellentesque feugiat ipsum eget dignissim mattis. Donec accumsan nibh sit amet mi ornare, a faucibus diam euismod. \" # Print 2nd line echo \"$example\" | sed -n '2 p' echo \"$example\" | sed '2! d' # Print 2-5th line only echo \"$example\" | sed -n '2,5 p' # Print from 3rd line until the end of the file echo \"$example\" | sed -n '2,$ p' # Delete lines thet contain 'Lorem' echo \"$example\" | sed '/Lorem/ d' # Replace all 'amet' with 'tema' echo \"$example\" | sed 's/amet/tema/g' # Replace second 'm' to 'M' in each line echo \"$example\" | sed 's:m:M:2' # Put 'ipsum' in square brackets echo \"$example\" | sed -E 's/(ipsum)/[\\1]/g' # Chain multiple commands together # replace the 2nd and third lines to numbers, then # print even numbers twice echo \"$example\" | sed \\  -e '2,3 s_^.*$_1234567890_' \\  -e 's/\\([02468]\\)/\u0026\u0026/g' AWK AWK is a record-based pattern-directed text processing language. It’s name comes from the last names of its creators.\nAn AWK script builds up from Pattern-Action pairs.\nAWK splits the input into records. Splits the records into fields.\nFrom start to end, match the defined patterns with the records, to determine whether it needs to perform the action of that pattern.\nIt allows you to write complex programs with it, I advise you to take some time to get familiar with the main functionality.\nNotable AWK flags  -F define input field separator regexp -f load code from a file -v var=value set variables before staring up  Patterns Empty pattern matches for every line.\nSpecial patterns BEGIN/END define action before the first input line is read, and after the last input is read respectively\nPatterns can be combined together:\n simple regular-expression  regular-expression is fenced by forward slashes   boolean operators: AND: \u0026\u0026, OR: ||, NOT: ! expression matchop regular-expression  matchop is one of the following ~ matches !~ does not match   expression relop expression  relational operator is one of the following  == Equal to  Greater than  Less than != Not equal to = Greater than or equal to  Less than or equal to     expression in array-name  array-name   (expr,expr,…) in array-name if 2 patterns are defined separated by a comma, then the action will be performed from the first occurrance of the fist pattern until the first occurrance of the second pattern  Actions  Missing action means to print the whole line. Actions are surrounded by curly brackets. Commands are terminated by semicolons/newlines/right braces. Fields can be accessed as $NUMBER, where number is the index of the field starting from 1. $0 contains the whole line. AWK has associative arrays, meaning its indexes can be strings, or numbers  You can define them in the following format: arrayname[index] = value AWK does not support multi-dimensional arrays, but you can emulate it by concatenating the dimension indixes as a string   In expressions the variables need not use $ signes in their names. Strings are concatenated together by spaces  We can write complex programs in our AWK actions to process the input fields.\nThe following lines come from the manual as-is. The parts between [] are optional, except when it refers to array indexing. Other characters are as-is.\n Statements  if( expression ) statement [ else statement ] while( expression ) statement for( expression ; expression ; expression ) statement for( var in array ) statement do statement while( expression ) break continue { [ statement ... ] } expression commonly var = expression print [ expression-list ] [  expression ] printf format [ , expression-list ] [  expression ] return [ expression ] next skip remaining patterns on this input line nextfile skip rest of this file, open next, start at top delete array[ expression ] delete an array element delete array delete all elements of array exit [ expression ] exit immediately; status is expression   Other functions  mathematical functions: atan2, cos, exp, log, sin, and sqrt length the length of its argument taken as a string, number of elements in an array for an array argument, or length of $0 if no argument. rand random number on [0,1). srand sets seed for rand and returns the previous seed. int truncates to an integer value. substr(s, m [, n]): the n-character substring of s that begins at position m counted from 1. If no n, use the rest of the string. index(s, t): the position in s where the string t occurs, or 0 if it does not. match(s, r): the position in s where the regular expression r occurs, or 0 if it does not. The variables RSTART and RLENGTH are set to the position and length of the matched string. split(s, a [, fs]): splits the string s into array elements a[1], a[2], ..., a[n], and returns n. The separation is done with the regular expression fs or with the field separator FS if fs is not given. An empty string as field separator splits the string into one array element per character. sub(r, t [, s]): substitutes t for the first occurrence of the regular expression r in the string s. If s is not given, $0 is used. gsub(r, t [, s]): same as sub except that all occurrences of the regular expression are replaced; sub and gsub return the number of replacements. sprintf(fmt, expr, ...): the string resulting from formatting expr ... according to the printf(3) format fmt. system(cmd): executes cmd and returns its exit status. This will be -1 upon error, cmd’s exit status upon a normal exit, 256 + sig upon death-by-signal, where sig is the number of the murdering signal, or 512 + sig if there was a core dump. tolower(str): returns a copy of str with all upper-case characters translated to their corresponding lower-case equivalents. toupper(str): returns a copy of str with all lower-case characters translated to their corresponding upper-case equivalents.    Special variables AWK provides information about the state of the processing and environment\n   variable name description     RS Specifies the record separator.   FS Specifies the field separator.   FIELDWIDTHS Specifies the field width.   OFS Specifies the Output separator.   ORS Specifies the Output separator.   NF Fields count of the line being processed.   NR Retrieves total count of processed records.   FNR The record which is processed.   ARGC Retrieves the number of passed parameters.   ARGV Retrieves the command line parameters.   ENVIRON Array of the shell environment variables and corresponding values.    AWK Examples # AWK examples from man page # Print lines longer than 72 characters. length($0)  72 # Print first two fields in opposite order. { print $2, $1 } # Same, with input fields separated # by comma and/or spaces and tabs. BEGIN { FS = \",[ \\t]*|[ \\t]+\" } { print $2, $1 } # Add up first column, print sum and average. { s += $1 } END { print \"sum is\", s, \" average is\", s/NR } # Print all lines between start/stop pairs. /start/, /stop/ # Simulate echo(1) BEGIN { for (i = 1; i  ARGC; i++) printf \"%s \", ARGV[i] printf \"\\n\" exit }  Learn more from this great tutorial  Disclaimer I did not get anything from making this post,\nMy main goal was to host an evolving cheatsheet for myself when I forget all this, and need to apply it quickly.\nI hope you learned something from it as well.\nHappy coding!\n","wordCount":"1853","inLanguage":"en","datePublished":"2021-02-18T00:00:00Z","dateModified":"2021-02-18T00:00:00Z","author":{"@type":"Person","name":"Mátyás Budavári"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://budavariam.github.io/posts/2021/02/18/grep-sed-awk-filters/"},"publisher":{"@type":"Organization","name":"Mátyás Budavári","logo":{"@type":"ImageObject","url":"https://budavariam.github.io/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://budavariam.github.io/ title="Mátyás Budavári (Alt + H)" class=site-avatar><img src=/avatar.png alt=logo aria-label=logo height=70 width=70></a><div class=site-info><h1 class=site-name><a href=https://budavariam.github.io/ accesskey=h title="Mátyás Budavári (Alt + H)">Mátyás Budavári</a></h1><p class=site-description>Developer from Szeged</p></div></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://budavariam.github.io/about/ title=About><span>About</span></a></li><li><a href=https://budavariam.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://budavariam.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://budavariam.github.io/archives/ title=Archive><span>Archive</span></a></li><li><span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Grep Sed AWK Filters</h1><div class=post-meta>February 18, 2021&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Mátyás Budavári</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#grep aria-label=Grep>Grep</a><ul><li><a href=#notable-grep-flags aria-label="Notable grep flags">Notable grep flags</a></li><li><a href=#grep-examples aria-label="Grep examples">Grep examples</a><ul><li><a href=#similar-utilities aria-label="Similar utilities">Similar utilities</a></li></ul></li></ul></li><li><a href=#sed aria-label=Sed>Sed</a><ul><li><a href=#notable-sed-flags aria-label="Notable sed flags">Notable sed flags</a></li><li><a href=#basic-commands aria-label="Basic commands">Basic commands</a><ul><li><a href=#addresses aria-label=Addresses>Addresses</a></li></ul></li><li><a href=#sed-examples aria-label="Sed Examples">Sed Examples</a></li></ul></li><li><a href=#awk aria-label=AWK>AWK</a><ul><li><a href=#notable-awk-flags aria-label="Notable AWK flags">Notable AWK flags</a></li><li><a href=#patterns aria-label=Patterns>Patterns</a></li><li><a href=#actions aria-label=Actions>Actions</a></li><li><a href=#special-variables aria-label="Special variables">Special variables</a></li><li><a href=#awk-examples aria-label="AWK Examples">AWK Examples</a></li></ul></li><li><a href=#disclaimer aria-label=Disclaimer>Disclaimer</a></li></ul></div></details></div><div class=post-content><p>I usually work with *nix systems, and I process text all the time.
This consists of CLI tool output, config file modifications and log files scanning.
These utilities make it easy to search and manipulate plaintext data.
I think they&rsquo;re an essential part of any developer&rsquo;s toolbox.</p><p>These commands can read either from the standard input, a single file or multiple files.</p><h2 id=grep>Grep<a hidden class=anchor aria-hidden=true href=#grep>#</a></h2><p>Grep&rsquo;s name comes from the <code>ed</code> command <code>g/re/p</code>, which roughly means, globally look for a regular expression and print.
Perfect for simple regex matches of single lines.</p><p><code>grep [flags] [pattern] [filenames]</code></p><h3 id=notable-grep-flags>Notable grep flags<a hidden class=anchor aria-hidden=true href=#notable-grep-flags>#</a></h3><ul><li><code>-E</code> extended regexp</li><li><code>-q</code> exit code marks the result (success is 0)</li><li><code>-v</code> lines that do not match</li><li><code>-n</code> matched line and line number</li><li><code>-l</code> only the names of files that contain a match</li><li><code>-c</code> count of the matching lines (not the number of matches)</li><li><code>-i</code> case insensitive match</li><li><code>-o</code> print only matching part (interesting with regex)</li><li><code>-e</code> define multiple patterns</li><li><code>--color</code> use colors <strong>always</strong>/<strong>never</strong>/<strong>auto</strong></li></ul><h3 id=grep-examples>Grep examples<a hidden class=anchor aria-hidden=true href=#grep-examples>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>example<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;\
</span><span style=color:#e6db74>For instance, on the planet Earth, man had always assumed
</span><span style=color:#e6db74>that he was more intelligent than dolphins because he had
</span><span style=color:#e6db74>achieved so much — the wheel, New York, wars and so on —
</span><span style=color:#e6db74>whilst all the dolphins had ever done was muck about in
</span><span style=color:#e6db74>the water having a good time. But conversely, the dolphins
</span><span style=color:#e6db74>had always believed that they were far more intelligent
</span><span style=color:#e6db74>than man — for precisely the same reasons.&#34;</span>

<span style=color:#75715e># Match exact text</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | grep <span style=color:#e6db74>&#39;man&#39;</span>
<span style=color:#75715e># Match exactly &#39;the&#39;, &#39;than&#39; or &#39;for&#39; words</span>
<span style=color:#75715e>#   case insensitive (\b is word boundary)</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | grep -iE <span style=color:#e6db74>&#39;\b(the|than|for)\b&#39;</span>
<span style=color:#75715e># Print only the matching part of the string</span>
<span style=color:#75715e>#   (can not print part of it, like groups)</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | grep -Eo <span style=color:#e6db74>&#39;dolphins \w+&#39;</span>
<span style=color:#75715e># Do not print lines that contain &#34;the&#34;</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | grep -Ev <span style=color:#e6db74>&#39;\bthe\b&#39;</span>
<span style=color:#75715e># Count the lines that contain &#34;good&#34;</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | grep -c <span style=color:#e6db74>&#39;good&#39;</span>
<span style=color:#75715e># Filter lines that contain a</span>
<span style=color:#75715e>#   punctuation mark OR start with a lowercase letter</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | grep --color<span style=color:#f92672>=</span>never -E -e <span style=color:#e6db74>&#39;[.,-]&#39;</span> -e <span style=color:#e6db74>&#39;^[a-z]&#39;</span>

</code></pre></div><h4 id=similar-utilities>Similar utilities<a hidden class=anchor aria-hidden=true href=#similar-utilities>#</a></h4><ul><li><code>egrep</code> - extended regex pattern, like <code>grep -E</code></li><li><code>fgrep</code> - faster, but works only for fixed patterns</li><li><code>zgrep</code>/<code>zegrep</code>/<code>zfgrep</code> - for compressed files</li><li><code>pgrep</code> - search processes and print the PID of matching ones</li><li><a href=https://beyondgrep.com/>ack-grep</a> has the functionality of grep, but optimized for developers</li><li><a href=https://github.com/ggreer/the_silver_searcher>silver seracher</a> is similar to ack, but faster</li></ul><h2 id=sed>Sed<a hidden class=anchor aria-hidden=true href=#sed>#</a></h2><p>Sed is a powerful stream editor.
For a more comprehensive guide check out this <a href=https://www.grymoire.com/Unix/Sed.html>awesome post</a>.</p><p>I&rsquo;ll show some commands that you can be productive with in no time.</p><p><code>sed [flags] [pattern] [filenames]</code></p><h3 id=notable-sed-flags>Notable sed flags<a hidden class=anchor aria-hidden=true href=#notable-sed-flags>#</a></h3><ul><li><code>-E</code> extended regexp</li><li><code>-n</code> show ony those lines, that we explicitly print</li><li><code>-e</code> chain multiple commands</li><li><code>-i</code> edit files in place</li></ul><h3 id=basic-commands>Basic commands<a hidden class=anchor aria-hidden=true href=#basic-commands>#</a></h3><ul><li>print: <code>p</code></li><li>delete: <code>d</code></li><li>substitute: <code>s/regexp pattern/replace to this string/modifiers</code><ul><li>fence characters after substitutiion that defines the fields can be any character,
choose one that does not appear in your patterns. It has to be a single character.</li><li>in replace string you can matching regular expression:<ul><li><code>&</code> to reference the whole pattern</li><li><code>\1</code>-<code>\9</code> to reference the groups by number</li></ul></li><li>modifiers can be:<ul><li><code>g</code>: global flag, match all occurrances in each line</li><li><code>p</code>: print result</li><li>NUMBER: the NUMBERth match in the line</li></ul></li></ul></li></ul><h4 id=addresses>Addresses<a hidden class=anchor aria-hidden=true href=#addresses>#</a></h4><p>You can optionally specify <strong>addresses</strong> before the command in which the command acts upon:</p><ul><li>line number</li><li>line range separated by comma, where the last line can be referenced with <code>$</code></li><li>a regular expression to define which lines do you want to run the script to fenced by forward slashes</li></ul><p>Addresses can be negated if you put a <code>!</code> between the address and the command.</p><h3 id=sed-examples>Sed Examples<a hidden class=anchor aria-hidden=true href=#sed-examples>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>example<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;\
</span><span style=color:#e6db74>Lorem ipsum dolor sit amet, consectetur adipiscing elit.
</span><span style=color:#e6db74>Ut ut enim quis nisl ultrices molestie eu in nibh.
</span><span style=color:#e6db74>In sit amet odio et tellus sagittis semper sed at urna.
</span><span style=color:#e6db74>Pellentesque feugiat ipsum eget dignissim mattis.
</span><span style=color:#e6db74>Donec accumsan nibh sit amet mi ornare, a faucibus diam euismod.
</span><span style=color:#e6db74>&#34;</span>

<span style=color:#75715e># Print 2nd line</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | sed -n <span style=color:#e6db74>&#39;2 p&#39;</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | sed <span style=color:#e6db74>&#39;2! d&#39;</span>
<span style=color:#75715e># Print 2-5th line only</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | sed -n <span style=color:#e6db74>&#39;2,5 p&#39;</span>
<span style=color:#75715e># Print from 3rd line until the end of the file</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | sed -n <span style=color:#e6db74>&#39;2,$ p&#39;</span>
<span style=color:#75715e># Delete lines thet contain &#39;Lorem&#39;</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | sed <span style=color:#e6db74>&#39;/Lorem/ d&#39;</span>
<span style=color:#75715e># Replace all &#39;amet&#39; with &#39;tema&#39;</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | sed <span style=color:#e6db74>&#39;s/amet/tema/g&#39;</span>
<span style=color:#75715e># Replace second &#39;m&#39; to &#39;M&#39; in each line</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | sed <span style=color:#e6db74>&#39;s:m:M:2&#39;</span>
<span style=color:#75715e># Put &#39;ipsum&#39; in square brackets</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | sed -E <span style=color:#e6db74>&#39;s/(ipsum)/[\1]/g&#39;</span>
<span style=color:#75715e># Chain multiple commands together</span>
<span style=color:#75715e>#   replace the 2nd and third lines to numbers, then</span>
<span style=color:#75715e>#   print even numbers twice</span>
echo <span style=color:#e6db74>&#34;</span>$example<span style=color:#e6db74>&#34;</span> | sed <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -e <span style=color:#e6db74>&#39;2,3 s_^.*$_1234567890_&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -e <span style=color:#e6db74>&#39;s/\([02468]\)/&amp;&amp;/g&#39;</span>
</code></pre></div><h2 id=awk>AWK<a hidden class=anchor aria-hidden=true href=#awk>#</a></h2><p>AWK is a record-based pattern-directed text processing language.
It&rsquo;s name comes from the last names of its creators.</p><p>An AWK script builds up from <a href=#patterns>Pattern</a>-<a href=#actions>Action</a> pairs.</p><p>AWK splits the input into records. Splits the records into fields.</p><p>From start to end, match the defined patterns with the records,
to determine whether it needs to perform the action of that pattern.</p><p>It allows you to write complex programs with it,
I advise you to take some time to get familiar with the main functionality.</p><h3 id=notable-awk-flags>Notable AWK flags<a hidden class=anchor aria-hidden=true href=#notable-awk-flags>#</a></h3><ul><li><code>-F</code> define input field separator regexp</li><li><code>-f</code> load code from a file</li><li><code>-v var=value</code> set variables before staring up</li></ul><h3 id=patterns>Patterns<a hidden class=anchor aria-hidden=true href=#patterns>#</a></h3><p>Empty pattern matches for every line.</p><p>Special patterns <code>BEGIN</code>/<code>END</code> define action before the
first input line is read, and after the last input is read respectively</p><p>Patterns can be combined together:</p><ul><li>simple regular-expression<ul><li>regular-expression is fenced by forward slashes</li></ul></li><li>boolean operators: AND: <code>&&</code>, OR: <code>||</code>, NOT: <code>!</code></li><li>expression <code>matchop</code> regular-expression<ul><li>matchop is one of the following</li><li><code>~</code> matches</li><li><code>!~</code> does not match</li></ul></li><li>expression <code>relop</code> expression<ul><li>relational operator is one of the following<ul><li><code>==</code> Equal to</li><li><code>></code> Greater than</li><li><code>&lt;</code> Less than</li><li><code>!=</code> Not equal to</li><li><code>>=</code> Greater than or equal to</li><li><code>&lt;=</code> Less than or equal to</li></ul></li></ul></li><li>expression in array-name<ul><li><a href=#arrays>array-name</a></li></ul></li><li>(expr,expr,&mldr;) in array-name</li><li>if 2 patterns are defined separated by a comma,
then the action will be performed from the
first occurrance of the fist pattern until the
first occurrance of the second pattern</li></ul><h3 id=actions>Actions<a hidden class=anchor aria-hidden=true href=#actions>#</a></h3><ul><li>Missing action means to print the whole line.</li><li>Actions are surrounded by curly brackets.</li><li>Commands are terminated by semicolons/newlines/right braces.</li><li>Fields can be accessed as <code>$NUMBER</code>, where number is the index of the field starting from 1. <code>$0</code> contains the whole line.</li><li>AWK has associative arrays, meaning its indexes can be strings, or numbers<ul><li>You can define them in the following format: <code>arrayname[index] = value</code></li><li>AWK does not support multi-dimensional arrays, but you can emulate it by concatenating the dimension indixes as a string</li></ul></li><li>In expressions the variables need not use <code>$</code> signes in their names.</li><li>Strings are concatenated together by spaces</li></ul><p>We can write complex programs in our AWK actions to process the input fields.</p><p>The following lines come from the manual as-is.
The parts between <code>[]</code> are optional, except when it refers to array indexing.
Other characters are as-is.</p><ul><li>Statements<ul><li><code>if( expression ) statement [ else statement ]</code></li><li><code>while( expression ) statement</code></li><li><code>for( expression ; expression ; expression ) statement</code></li><li><code>for( var in array ) statement</code></li><li><code>do statement while( expression )</code></li><li><code>break</code></li><li><code>continue</code></li><li><code>{ [ statement ... ] }</code></li><li><code>expression</code> commonly var = expression</li><li><code>print [ expression-list ] [ > expression ]</code></li><li><code>printf format [ , expression-list ] [ > expression ]</code></li><li><code>return [ expression ]</code></li><li><code>next</code> skip remaining patterns on this input line</li><li><code>nextfile</code> skip rest of this file, open next, start at top</li><li><code>delete array[ expression ]</code> delete an array element</li><li><code>delete array</code> delete all elements of array</li><li><code>exit [ expression ]</code> exit immediately; status is expression</li></ul></li><li>Other functions<ul><li>mathematical functions: <code>atan2</code>, <code>cos</code>, <code>exp</code>, <code>log</code>, <code>sin</code>, and <code>sqrt</code></li><li><code>length</code> the length of its argument taken as a string, number of elements in
an array for an array argument, or length of <code>$0</code> if no argument.</li><li><code>rand</code> random number on <code>[0,1)</code>.</li><li><code>srand</code> sets seed for rand and returns the previous seed.</li><li><code>int</code> truncates to an integer value.</li><li><code>substr(s, m [, n])</code>: the n-character substring of s that begins at position
<code>m</code> counted from <code>1</code>. If no <code>n</code>, use the rest of the string.</li><li><code>index(s, t)</code>: the position in <code>s</code> where the string <code>t</code> occurs, or <code>0</code> if it does not.</li><li><code>match(s, r)</code>: the position in <code>s</code> where the regular expression <code>r</code> occurs, or
<code>0</code> if it does not. The variables <code>RSTART</code> and <code>RLENGTH</code> are set to the position
and length of the matched string.</li><li><code>split(s, a [, fs])</code>: splits the string <code>s</code> into array elements
<code>a[1], a[2], ..., a[n]</code>, and returns <code>n</code>. The separation is done with the regular expression
<code>fs</code> or with the field separator <code>FS</code> if <code>fs</code> is not given.
An empty string as field separator splits the string into one array element per character.</li><li><code>sub(r, t [, s])</code>: substitutes <code>t</code> for the first occurrence of the regular expression <code>r</code>
in the string <code>s</code>. If <code>s</code> is not given, <code>$0</code> is used.</li><li><code>gsub(r, t [, s])</code>: same as <code>sub</code> except that all occurrences of the
regular expression are replaced; <code>sub</code> and <code>gsub</code> return the number of replacements.</li><li><code>sprintf(fmt, expr, ...)</code>: the string resulting from formatting <code>expr ...</code>
according to the printf(3) format <code>fmt</code>.</li><li><code>system(cmd)</code>: executes <code>cmd</code> and returns its exit status.
This will be <code>-1</code> upon error, <code>cmd</code>&rsquo;s exit status upon a normal exit,
256 + sig upon death-by-signal, where sig is the
number of the murdering signal, or 512 + sig if there was a core dump.</li><li><code>tolower(str)</code>: returns a copy of <code>str</code> with all upper-case characters
translated to their corresponding lower-case equivalents.</li><li><code>toupper(str)</code>: returns a copy of <code>str</code> with all lower-case characters
translated to their corresponding upper-case equivalents.</li></ul></li></ul><h3 id=special-variables>Special variables<a hidden class=anchor aria-hidden=true href=#special-variables>#</a></h3><p>AWK provides information about the state of the processing and environment</p><table><thead><tr><th style=text-align:left>variable name</th><th style=text-align:left>description</th></tr></thead><tbody><tr><td style=text-align:left><code>RS</code></td><td style=text-align:left>Specifies the record separator.</td></tr><tr><td style=text-align:left><code>FS</code></td><td style=text-align:left>Specifies the field separator.</td></tr><tr><td style=text-align:left><code>FIELDWIDTHS</code></td><td style=text-align:left>Specifies the field width.</td></tr><tr><td style=text-align:left><code>OFS</code></td><td style=text-align:left>Specifies the Output separator.</td></tr><tr><td style=text-align:left><code>ORS</code></td><td style=text-align:left>Specifies the Output separator.</td></tr><tr><td style=text-align:left><code>NF</code></td><td style=text-align:left>Fields count of the line being processed.</td></tr><tr><td style=text-align:left><code>NR</code></td><td style=text-align:left>Retrieves total count of processed records.</td></tr><tr><td style=text-align:left><code>FNR</code></td><td style=text-align:left>The record which is processed.</td></tr><tr><td style=text-align:left><code>ARGC</code></td><td style=text-align:left>Retrieves the number of passed parameters.</td></tr><tr><td style=text-align:left><code>ARGV</code></td><td style=text-align:left>Retrieves the command line parameters.</td></tr><tr><td style=text-align:left><code>ENVIRON</code></td><td style=text-align:left>Array of the shell environment variables and corresponding values.</td></tr></tbody></table><h3 id=awk-examples>AWK Examples<a hidden class=anchor aria-hidden=true href=#awk-examples>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-awk data-lang=awk><span style=color:#75715e># AWK examples from man page</span>
<span style=color:#75715e># Print lines longer than 72 characters.</span>
<span style=color:#66d9ef>length</span>(<span style=color:#f92672>$</span><span style=color:#ae81ff>0</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>72</span>

<span style=color:#75715e># Print first two fields in opposite order.</span>
{ <span style=color:#66d9ef>print</span> <span style=color:#f92672>$</span><span style=color:#ae81ff>2</span>, <span style=color:#f92672>$</span><span style=color:#ae81ff>1</span> }

<span style=color:#75715e># Same, with input fields separated</span>
<span style=color:#75715e>#   by comma and/or spaces and tabs.</span>
BEGIN { FS <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;,[ \t]*|[ \t]+&#34;</span> }
      { <span style=color:#66d9ef>print</span> <span style=color:#f92672>$</span><span style=color:#ae81ff>2</span>, <span style=color:#f92672>$</span><span style=color:#ae81ff>1</span> }

<span style=color:#75715e># Add up first column, print sum and average.</span>
     { <span style=color:#a6e22e>s</span> <span style=color:#f92672>+=</span> <span style=color:#f92672>$</span><span style=color:#ae81ff>1</span> }
END  { <span style=color:#66d9ef>print</span> <span style=color:#e6db74>&#34;sum is&#34;</span>, <span style=color:#a6e22e>s</span>, <span style=color:#e6db74>&#34; average is&#34;</span>, <span style=color:#a6e22e>s</span><span style=color:#f92672>/</span>NR }

<span style=color:#75715e># Print all lines between start/stop pairs.</span>
<span style=color:#e6db74>/start/</span>, <span style=color:#e6db74>/stop/</span>

<span style=color:#75715e># Simulate echo(1)</span>
BEGIN {
  <span style=color:#66d9ef>for</span> (<span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> ARGC; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) <span style=color:#66d9ef>printf</span> <span style=color:#e6db74>&#34;%s &#34;</span>, ARGV[<span style=color:#a6e22e>i</span>]
  <span style=color:#66d9ef>printf</span> <span style=color:#e6db74>&#34;\n&#34;</span>
  <span style=color:#66d9ef>exit</span>
}
</code></pre></div><ul><li>Learn more <a href=https://www.tutorialspoint.com/awk/index.htm>from this great tutorial</a></li></ul><h2 id=disclaimer>Disclaimer<a hidden class=anchor aria-hidden=true href=#disclaimer>#</a></h2><p>I did not get anything from making this post,</p><p>My main goal was to host an evolving cheatsheet for myself
when I forget all this, and need to apply it quickly.</p><p>I hope you learned something from it as well.</p><p>Happy coding!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://budavariam.github.io/tags/programming/>programming</a></li><li><a href=https://budavariam.github.io/tags/developer-toolbox/>developer-toolbox</a></li><li><a href=https://budavariam.github.io/tags/grep/>grep</a></li><li><a href=https://budavariam.github.io/tags/sed/>sed</a></li><li><a href=https://budavariam.github.io/tags/awk/>AWK</a></li><li><a href=https://budavariam.github.io/tags/cheatsheet/>cheatsheet</a></li></ul><div class=share-buttons><div class=addthis_inline_share_toolbox></div><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-602c2f70bcebfd93"></script></div></div></footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//budavariam.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2021 <a href=https://budavariam.github.io/>Mátyás Budavári</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://github.com/budavariam/hugo-PaperMod rel=noopener target=_blank>PaperMod (custom)</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>